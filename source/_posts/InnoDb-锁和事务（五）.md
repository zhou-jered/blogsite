---
title: InnoDb 锁和事务（五）
date: 2017-08-09 14:57:38
tags:
	- Note
	- MySQL
	- InnoDB
---

这篇将在InnoDB中不同的SQL语句都会分别设置怎样的锁

在进行锁定读操作的时候，不管UPDATE或者DELETE语句的where子句中过滤了哪些行，InnoDB都会锁定扫描到的索引记录。因为InnoDb感知不到正在扫面的行，只能感知到扫描到的索引范围。而且这些锁通常是后键锁，这个锁避免了在扫描到的索引前面的空闲空间插入数据。

如果在查询中使用了二级索引而且索引记录锁是排它锁，InnoDb同样会取出相应的集群索引并且在上面加锁。

如果你的表里面没有索引的话，每次查询都得全表扫描，还会全表加锁，gg了。

对于SELECT ... FOR UPDATE 和  SELECT ... LOCK IN SHARE MODE语句来说，会锁定扫描的行，希望能够在通过where子句过滤出并释放掉和结果不匹配的行的锁，但在有些情况下，不匹配行的锁并不会被释放掉，这是由于结果集和原始表的关系在查询执行过程中被丢失了。举个例子，在UNION的情况下，扫描到的行会在计算是否和结果集匹配之前就插入到一个临时表中，这时候原表中的行就会被锁定直到查询结束。

## InnoDB 对应不同的语句设置的锁如下

+ SELECT ... FROM 是一致性读，从数据快·照中读取数据，并不会设置任何锁，除非事务隔离级别是SERIALIZEABLE， 对于SERIALIZEABLE的隔离级别，查询操作会在遇到的索引上设置后键锁。然而，在唯一索引上使用唯一查询条件的话只会设置记录锁，也就是没有间隙锁。

+ SELECT ... FROM ... LOCK IN SHARE MODE 在所有查询遇到的索引上设置共享后键锁，同样的，在使用唯一索引来查询唯一行的话，只会设置记录锁。
+ SELECT ... FROM ... FOR UPDATE 在查询遇到的索引记录上设置排它后键锁，同样，使用唯一索引查询唯一行，设置排它记录锁。
+ UPDATE ... WHERE ... 排它后键锁，唯一索引查询唯一记录行--设置记录锁
+ UPDATE 当update更新集群索引记录时，在二级索引上会添加隐式的锁，update操作在插入数据前做duplicate key检查的时候会在相关的二级索引上设置共享锁，在插入新的二级索引的时候也会设置。
+ DELETE FROM ... WHERE ... 在扫描到的索引上设置排它后键锁，唯一索引设置记录锁。
+ INSERT 在插入的行上设置排它锁，这只是记录锁，并不是后键锁，并不能避免其他session在插入行的前面空闲索引空间中插入数据。
在插入一行数据之前，一个间隙锁也叫做插入意向锁会被设置，多个事务在同一个间隙中的不同行同时插入数据是不会互相影响的，因为相同范围的间隙锁都能拿到，但是同一行上的排它锁只有一个事务能拿到，但是由于插入的行不一样，所以可以同时在同一个间隙范围内插入不同的行。
如果duplcate-key错误发生了，一个共享锁会在duplicate的索引上被设置，这种用法会导致死锁的发生，如果有多个session尝试插入，但是此时插入目标行上的XLock被别的事务获取，当X Lock释放的时候，所有尝试插入的session会获取一个共享锁，此时就会发生死锁，因为这些事务都在等待其他事务释放共享锁。

+ INSERT ... ON DUPLICATE KEY UPDATE 和普通的insert语句在遇到duplicate key错误时设置共享锁的行为不一样，这个语句在遇到错误时会设置排它记录锁，在唯一键上发生duplciate key错误的时候会设置排它后键锁。

+ REPLACE 如果没有冲突发生的话，行为跟insert语句类似，否则的话，排它后键锁就会设置在将被替换的行上。

+ INSERT INTO T SELECT ... FROM S WHERE ... 在T表中将会被插入的行上设置排它记录锁（没有间隙锁）。如果事务隔离级别是READ COMMITEED，或者配置项`innodb_locks_unsafe_for_binlog`启用而且事务隔离界别是SERIALIZABLE，InnoDB在S中的搜索就是一致性读操作（无锁）。其他情况下，InnoDB会在S上相应的行上设置共享后键锁。

+ AUTO_INCREMENT
在访问自增列的时候，InnoDB会设置一种叫做自增锁的锁，这种锁只会持有到访问自增列的语句结束，而不会持有到整个事务的结束。
InnoDB在获取自增列前一个值的时候不会设置任何的锁。

+ FOREIGN
如果一个表中存在外键的话，任何插入，更新，删除操作都出触发限制条件检查，在做这个检查的时候，会在爱外键关联的表上设置共享记录锁。即使限制条件检查失败也会设置锁。

+ LOCK TABLES
设置表锁，但是这是在比InnoDB层面更高的MySQL层次设置的锁，如果配置项innodb_table_locks=1而且autocommit=0，InnoDB就能感知到表被锁住了。而且InnoDB上面的MySQL层也直到行级别的锁。
在其他方面，InnoDB的死锁自动检测在表锁存在的情况下是不能检测到死锁的，这是因为在这种情况下，高层次的MySQL不知道行锁的情况，在其他session拥有一个表的一些行锁的时候，另外的session还是能够获取到表锁的。然而这种情况不会影响事务的正确性，在[这里](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html)查看更多的信息。
