---
title: InnoDb 锁和事务（七）
date: 2017-08-10 11:30:55
tags:
	- Note
	- MySQL
	- InnoDB
	- Deadlock
---

这篇主要讲死锁，包括示例，检测和回滚，死锁的避免。


## InnoDB 死锁示例
假设有两个客户端A和B。
首先，A创建一个只有一行数据的表，然后开始一个事务，在这个事务范围内，A获取唯一行数据的S Lock。
```SQL
CREATE TABLE T (I INT) ENGINE=INNODB;
INSERT INTO T () VALUES (1);
START TRANSACTION;
SELECT * FROM T WHERE I=1 LOCK IN SHARE MODE
```
然后，B开始一个事务，尝试着删除表中的数据。
```SQL
START TRANSACTION;
DELETE FROM T WHERER I=1;
```
由于删除操作会获取X Lock，由于X Lock和A已经持有的S Lock不兼容，所以删除操作会进入获取锁的等待队列，此时B阻塞。

最后，A也尝试着删除表中数据。
```SQL
DELETE FROM T WHERE I=1
```
此时就会发生死锁，因为此时A需要行上的X Lock，而此时B正在请求行上的X Lock，B正在等待A释放S Lock。由于A持有的S Lock由于B请求的存在而不能升级为X Lock，此时A和B陷入来互相等待中，死锁发生。结果就是，InnoDB给其中一个客户端生成一个发生死锁的错误，然后释放它的锁。另一个客户端就会执行成功。

## 死锁检测和回滚
InnoDB的死锁自动检测是默认开启的，InnoDB在检测到死锁之后会选择一个涉及到的数据规模比较小的事务进行回滚来打破死锁，这个数据规模的决定是根据事务进行插入，更新，删除的数据行数量来判断的。

在InnoDB不知道MySQL层面的表锁的时候是不能检测和表锁相关的死锁的，由其他的数据引擎设置的锁参与的死锁情况，InnoDB也没法检测，解决这种情况的办法就是设置获取锁的等待时间，配置系统变量innodb_lock_wait_timeout。

当InnoDB执行事务的完全回滚时，事务获取的所有锁都会被释放。然而如果只有一个语句出错的返回结果是回滚的话，那么其他语句的的锁也许能够被保留，这样做（事务内锁全部释放）的原因是因为InnoDB的行锁存储形式决定了InnoDB不知道接下来的锁是被那个语句设置的。

如果SELECT语句在事务内调用了存储过程，存储过程里面的一个语句失败了，语句就会回滚，而且，如果接下来回滚的话就是事务完全回滚。

如果在InnoDB的监控器里面的LATEST DETECTED DEADLOCK部分看到了这条信息
> “TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,” 

这表明事务的wait-for列表长度超过的最大限制200，此时InnoDB就会把事务看作发生了死锁，同样的，如果必须在事务的wait-for列表中查找超过100万个锁的话，也会出现这个错误。

### 考虑禁用自动死锁检测
在高并发的系统中，死锁检测在大量线程等待锁的时候会显著降低程序性能，这时候，死锁的避免可以依靠设置innodb_lock_wait_timeout系统变量来完成，这个变量设置来等待获取锁的最大时间。死锁检测的禁用可以通过配置项innodb_deadlock_detect来设置。

## 怎么避免和处理死锁
这部分的内容建立在你理解了死锁和回滚机制的基础上，接下来会解释怎么组织数据库操作来尽可能的避免死锁和随后的程序处理操作。

死锁是事务型数据库的一个经典问题，但是并不是一个大问题，除非你的程序因为死锁过多而无法顺利执行任何事务。一般来讲，你的程序应该做好由于死锁回滚而重新执行数据库操作的准备。

InnoDB使用自动化的行锁，所以你也许会在单行数据的操作中遭遇死锁，这是因为即使单行的操作也并不是原子操作，这通常会在插入或者删除的相应索引记录上加锁。

以下是避免和应对死锁发生的一些技术点
- 在任何时候，使用`SHOW ENGINE INNODB STATUS`来查看最近死锁的的原因，这可以帮助你的程序来避免死锁。
- 如果死锁太多了，怎么办？可以通过开启innodb_print_all_deadlock配置项来收集debug信息，每个死锁的信息都会打印到MySQL的[Error Log](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_error_log)。别忘记在debug完之后关闭这个选项。
- 永远准备着在死锁发生的时候重新执行你的sql，别担心，死锁没事，重新执行就行了。
- 保持事务尽可能的短小来减小锁冲突的概率。
- 在完成数据修改的时候立马提交事务。特别的，不要在mysql的交互shell里面长时间的打开未提交事务。
- 如果你有读锁定的操作，使用较为低级别的隔离界别，比如READ COMMITTED
- 在更改多个表或者多个行的时候，在每次更改的时候使用一致性的顺序修改。然后事务就会形成完好的队列而不会死锁。比如，把程序中数据库操作组织成函数方法，或者使用存储过程，而不要把相似的语句到处乱放。
- 合理的建立索引可以让你在查询的时候扫描尽量少的索引而建立范围更小的锁，使用`EXPLAIN`来查看你的查询语句是如果使用索引的。
- 能不用锁就不用
- 最后，如果是在没办法的话，可以使用表锁，在事务开始之前锁定表，然后执行事务，提交之后，解锁表。但是会导致数据库并发性下降。
- 另一个串行化事务的方法是使用一个辅助表，这个表中只有一行数据，在每个事务开始之前更新这个表来实现串行化。注意InnoDB的实时死锁检测在这样的情况下也能正常工作，因为这个辅助表中数据作为串行话的锁实际上也是一个行锁。在使用表锁的时候，必须用超时机制来解决死锁的问题。
