---
title: InnoDb 锁和事务（五）
date: 2017-08-09 14:57:38
tags:
	- Note
	- MySQL
	- InnoDB
---

这篇将在InnoDB中不同的SQL语句都会分别设置怎样的锁

锁定读操作，UPDATE或者DELETE语句通常会锁定扫描到的索引记录，不管where子句中过滤了哪些行，InnoDb感知不到扫描的行，只能感知到扫描到的索引范围。这些锁通常是后键锁，这个锁的使用避免了在扫描到索引的前面空闲空间插入数据，然后，间隙锁可以通过配置被禁用。

如果在查询中使用了二级索引而且索引记录锁是排它锁，InnoDb同样会取出相应的集群索引并且在上面加锁。

如果你的表里面没有索引的话，每次查询都得全表扫描，还会全表加锁，gg了。

对于SELECT ... FOR UPDATE 和  SELECT ... LOCK IN SHARE MODE语句来说，会锁定扫描的行，希望能够在通过where子句过滤出并释放掉和结果不匹配的行的锁，但在有些情况下，不匹配行的锁并不会被释放掉，这是由于结果集和原始表的关系在查询执行过程中被丢失了。举个例子，在UNION的情况下，扫描到的行会在计算是否和结果集匹配之前就插入到一个临时表中，这时候原表中的行就会被锁定直到查询结束。

## InnoDB 对应不同的语句设置的锁如下

+ SELECT ... FROM 是一致性读，从数据快·照中读取数据，并不会设置任何锁，除非事务隔离级别是SERIALIZEABLE， 对于SERIALIZEABLE的隔离级别，查询操作会在遇到的索引上设置后键锁。然而，在唯一索引上使用唯一查询条件的话只会设置记录锁，也就是没有间隙锁。

+ SELECT ... FROM ... LOCK IN SHARE MODE 在所有查询遇到的索引上设置共享后键锁，同样的，在使用唯一索引来查询唯一行的话，只会设置记录锁。
+ SELECT ... FROM ... FOR UPDATE 在查询遇到的索引记录上设置排它后键锁，同样，使用唯一索引查询唯一行，设置排它记录锁。
+ UPDATE ... WHERE ... 排它后键锁，唯一索引查询唯一记录行--设置记录锁
+ UPDATE 当update更新集群索引记录时，在二级索引上会添加隐式的锁，update操作在插入数据前做duplicate key检查的时候会在相关的二级索引上设置共享锁，在插入新的二级索引的时候也会设置。
+ DELETE FROM ... WHERE ... 在扫描到的索引上设置排它后键锁，唯一索引设置记录锁。
+ INSERT 在插入的行上设置排它锁，这只是记录锁，并不是后键锁，并不能避免其他session在插入行的前面空闲索引空间中插入数据。
在插入一行数据之前，一个间隙锁也叫做插入意向锁会被设置，多个事务在同一个间隙中的不同行同时插入数据是不会互相影响的，因为相同范围的间隙锁都能拿到，但是同一行上的排它锁只有一个事务能拿到，但是由于插入的行不一样，所以可以同时在同一个间隙范围内插入不同的行。
如果duplcate-key错误发生了，一个共享锁会在duplicate的索引上被设置，这种用法会导致死锁的发生，如果有多个session尝试插入，但是此时插入目标行上的XLock被别的事务获取，当X Lock释放的时候，所有尝试插入的session会获取一个共享锁，此时就会发生死锁，因为这些事务都在等待其他事务释放共享锁。

+ INSERT ... ON DUPLICATE KEY UPDATE 和普通的insert语句在遇到duplicate key错误时设置共享锁的行为不一样，这个语句在遇到错误时会设置排它记录锁，在唯一键上发生duplciate key错误的时候会设置排它后键锁。

+ REPLACE 如果没有冲突发生的话，行为跟insert语句类似，否则的话，排它后键锁就会设置在将被替换的行上。

+ INSERT INTO T SELECT ... FROM S WHERE ... 在T表中将会被插入的行上设置排它记录锁（没有间隙锁）。如果事务隔离级别是READ COMMITEED，或者配置项`innodb_locks_unsafe_for_binlog`启用而且事务隔离界别是SERIALIZABLE，InnoDB在S中的搜索就是一致性读操作（无锁）。其他情况下，InnoDB会在S上相应的行上设置共享后键锁。

+ AUTO_INCREMENT

+ FOREIGN
+ LOCK TABLES
